// -------------------------------------------------- //
// This file is autogenerated by pioasm; do not edit! //
// -------------------------------------------------- //

#pragma once

#if !PICO_NO_HARDWARE
#include "hardware/pio.h"
#endif

// ------- //
// counter //
// ------- //

#define counter_wrap_target 3
#define counter_wrap 8
#define counter_push_it 6

static const uint16_t counter_program_instructions[] = {
    0xe040, //  0: set    y, 0                       
    0x80a0, //  1: pull   block                      
    0x6020, //  2: out    x, 32                      
            //     .wrap_target
    0x0084, //  3: jmp    y--, 4                     
    0x8080, //  4: pull   noblock                    
    0x60a0, //  5: out    pc, 32                     
    0x0087, //  6: jmp    y--, 7                     
    0xa0ca, //  7: mov    isr, !y                    
    0x8020, //  8: push   block                      
            //     .wrap
};

#if !PICO_NO_HARDWARE
static const struct pio_program counter_program = {
    .instructions = counter_program_instructions,
    .length = 9,
    .origin = -1,
};

static inline pio_sm_config counter_program_get_default_config(uint offset) {
    pio_sm_config c = pio_get_default_sm_config();
    sm_config_set_wrap(&c, offset + counter_wrap_target, offset + counter_wrap);
    return c;
}

static inline void counter_program_init(PIO pio, uint sm, uint offset) {
	pio_sm_config c = counter_program_get_default_config(offset);
	pio_sm_init(pio, sm, offset, &c);
	pio_sm_set_enabled(pio, sm, true);
  // Put main loop start address into fifo
  pio_sm_put(pio, sm, counter_wrap_target + offset);
}

static inline uint64_t retrieve_counter(PIO pio, uint sm, uint offset) {
  static union {
    uint64_t full64;
    struct { // RP2040 is little endian
      uint32_t lo32;
      uint32_t hi32;
    } split;
  } counter;

  // Retrieve new (32 bit) counter value
  pio_sm_put(pio, sm, counter_push_it + offset);
  uint32_t new_counter_lo = pio_sm_get_blocking(pio, sm);

  // Handle overflow situation
  counter.split.hi32 += (new_counter_lo < counter.split.lo32);

  // Update lower part of counter
  counter.split.lo32 = new_counter_lo;

  return counter.full64;
}

#endif
